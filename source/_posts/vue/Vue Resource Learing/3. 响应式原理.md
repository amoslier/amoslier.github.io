---
title: Vue源码学习 - 响应式原理
categories:
  - [Vue,源码]
tags: 
---

# 响应式原理

## 入口

```js
initState() {
  vm._watchers = []
  const opts = vm.$options
  if (opts.props) initProps(vm, opts.props)
  if (opts.methods) initMethods(vm, opts.methods)
  if (opts.data) initData(vm)
  else observe(vm._data = {}, true /* asRootData */)
  if (opts.computed) initComputed(vm, opts.computed)
  if (opts.watch && opts.watch !== nativeWatch) initWatch(vm, opts.watch)
}
```

## initState

- `initProps`
- `initMethods`
- `initData`
- `initComputed`
- `initWatch`

> 思考：为什么 Vue 中能通过 this 直接访问，`props、methods、computed、data` 中的数据？
>
> 这也就是 `initProps、initMethods、initData、initComputed` 的作用，在内部会将数据通过 `proxy` 代理到全局的 `_data` 中，因此可以访问

## initData

- `Object.defineProperty` 数据拦截
- `Dep` 依赖收集
- `Wathcer` 

```js
// 过程
Observer -> defineReactive -> dep = new Dep() -> Object.definProperty() -> getter、setter
	getter -> if(Dep.terget) -> dep.depend() 
    		 -> Dep.target.addDep(this) -> dep.addSub(this)
	setter -> dep.notify() 
    		 -> watcher.update() -> watcher.dirty = true -> watcher.run() -> watcher.get()
```

> `Dep.target` 是什么？
>
> Dep.target 为 Dep 类的一个静态属性，值为 watcher，在实例化 Watcher 时会被设置。
>
> 也就是说，当 new Watcher(vm, exp, cb, options) 时，会执行传递的回调函数，若回调中存在 vm.key 读取行为，将会设置 Dep.target 为当前的 watcher，进而进行后续的依赖收集。

> `watcher.dirty` 有什么作用？
>
> `dirty` 其实就是 `Computed` 属性的能够进行缓存的核心。
>
> `Computed` 实际上还是通过 `watch` 去实现的，只不过采用的是懒执行的方式。然而 `watcher` 懒执行的时候会执行 `evaluate` 方法，这里会将 `dirty` 置为 `false`。然而 `Computed` 在初始化的时候会创建一个专有的 `ComputedGetter`，类似普通的 `getter` 函数，每次执行`computedGetter`就会判断 `watcher.dirty` ，若为`true`执行 `evaluate`，最后返回 `watcher.value`。
>
> 那么什么时候 `dirty` 为 `true` 呢？
>
> 实际上是当调用 `Watcher.update` 方法的时候会将其置为 `true`。我们知道当数据发生变化时，会调用 `setter` 方法，并执行 `watcher.update` 。因此也保证了，在一次渲染中，`computed` 只会执行一次。