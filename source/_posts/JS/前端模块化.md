---
title: 前端模块化
categories:
  - [JavaScript]
tags: 
---

# 前端模块化

## 模块化解决了什么问题？

在软件工程的设计原则中，有一个原则叫“单一职责”

“单一职责” 的目的就是减少功能维护带来的风险，把代码块的职责单一化，让代码的可维护性更高。

一个完整业务的内部实现，不应该把各种代码都耦合在一起，而应该按照职责去划分好代码块，再进行组合，形成一个 “高内聚，低耦合” 的工程设计。

模块化就是由此而来，在前端工程里，每个单一职责的代码块，就叫做模块（ Module ） ，模块有自己的作用域，功能与业务解耦，非常方便复用和移植。

## 实现模块化的方式

- CommonJS
- ES Module
- UMD
- AMD

如今基本都是 ESM 和 CJS 的天下。

## CommonJS

### 基本语法

CJS 使用 `module.exports` 语法导出模块，可以导出任意合法的 JavaScript 类型，例如：字符串、布尔值、对象、数组、函数等等。

使用 `require` 导入模块，在导入的时候，当文件扩展名是 `.js` 时，可以只写文件名，而此时使用的是 `.cjs` 扩展名，所以需要完整的书写。

### 默认导出

```js
/** 导出 */
modules.exports = 'hello world'

/** 导入 */
const h = require('./module.js')
console.log(h)
```

### 命名导出（对象）

```js
/** 导出 */
function foo() {
  console.log('hello')
}

const bar = 'Akira'

module.exports = { foo, bar }

/** 导入*/
const h = require('./module.js')
/** 导入通过对象解构 更改命名 */
const { newFoo: foo, newBar: bar } = require('./module.js')
console.log(h) // { foo: [Function: foo], bar: 'Akira' }
h.foo() // hello
console.log(h.bar) // Akira
```

## ES Module

ES Module 是新一代的模块化标准，它是在 ES6（ ECMAScript 2015 ）版本推出的，是原生 JavaScript 的一部分。

### 基本语法

ESM 使用 `export default` （默认导出）和 `export` （命名导出）这两个语法导出模块，和 CJS 一样， ESM 也可以导出任意合法的 JavaScript 类型，例如：字符串、布尔值、对象、数组、函数等等。

使用 `import ... from ...` 导入模块，在导入的时候，如果文件扩展名是 `.js` 则可以省略文件名后缀，否则需要把扩展名也完整写出来。

### 默认导出

```js
/** 导出1 */
export default 'hello'

/** 导出2 */
function foo() { console.log('hello') }
const bar = 'Akira'

export default { foo, bar } // 虽然默认导出对象，但不能直接通过解构获取

/** 导入1 */
import h from './module.js'
console.log(h)

/** 导出2 */
import h from './module.js'
```

### 命名导出

```js
/** 导出 */
export function foo() { console.log('hello') }
export const bar = 'Akira

/** 导入 */
import { foo, bar } from './module.js'
/** 命名导入 */
import * as h from './module.js'
import { foo as newFoo, bar as newB } from './module.js'
```

